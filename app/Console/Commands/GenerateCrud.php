<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

class GenerateCrud extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'make:crud
        {model : Model name}
        {--fields= : Fields like name:string, status:enum(open,closed)}
        {--relations= : Relations like tasks:hasMany, user:belongsTo}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Generate CRUD (Model, Migration, Controller, Requests, Views)';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        // Get the name of the model and capitalize it
        $modelName = ucfirst($this->argument('model'));

        // Retrieve the specified fields and relations options
        $fields = $this->option('fields');
        $relations = $this->option('relations');

        // Parse the fields option into an array format
        $fieldArray = $this->parseFields($fields);

        // Notify that the CRUD generation process has started
        $this->info("Generating CRUD for: {$modelName}");

        // Generate the necessary components for the CRUD functionality
        $this->generateModel($modelName, $fieldArray, $relations);
        $this->generateMigration($modelName, $fieldArray);
        $this->generateController($modelName);
        $this->generateRequests($modelName, $fieldArray);
        $this->generateViews($modelName);

        // Notify that the CRUD generation process has completed successfully
        $this->info("CRUD for {$modelName} generated successfully!");
    }

    /**
     * Generates a model file with the given name, fields, and relationships.
     * The model file is generated by replacing placeholders in a stub template with actual data.
     *
     * @param string $modelName The name of the model to be generated.
     * @param array $fieldArray An array of field specifications in the format: 'name:type'.
     * @param string|null $relations A comma-separated list of relationships in the format: 'name:type'.
     */
    protected function generateModel($modelName, $fieldArray, $relations)
    {
        // Generate the fillable fields from the field array
        $fillable = $this->parseFieldsForFillable($fieldArray);

        // Initialize an empty string for relation methods
        $relationMethods = "";

        // If relations are provided, generate relation methods
        if ($relations) {
            $relationArray = explode(',', $relations);
            foreach ($relationArray as $relation) {
                [$name, $type] = explode(':', $relation);
                $relationMethods .= "\n\tpublic function {$name}()\n\t{\n";
                $relationMethods .= "\t\treturn \$this->{$type}(" . Str::studly(Str::singular($name)) . "::class);\n\t}\n";
            }
        }

        // Load the model stub template
        $stub = file_get_contents(app_path('Console/Commands/stubs/model.stub'));

        // Replace placeholders in the stub with actual model data
        $stub = str_replace(
            ['{{model}}', '{{fillable}}', '{{relations}}'],
            [$modelName, $fillable, $relationMethods],
            $stub
        );

        // Write the generated model to the Models directory
        File::put(app_path("Models/{$modelName}.php"), $stub);
    }

    /**
     * Generates a migration file for creating a table corresponding to the given model.
     * The migration includes field definitions based on the provided field array.
     *
     * @param string $modelName The name of the model for which the migration is generated.
     * @param array $fieldArray An array of field specifications in the format: 'name:type[:values]'.
     */
    protected function generateMigration($modelName, $fieldArray)
    {
        // Generate the table name by converting the model name to snake_case and pluralizing it
        $tableName = Str::snake(Str::plural($modelName));

        // Generate the migration fields based on the field array
        $migrationFields = $this->parseFieldsForMigration($fieldArray);

        // Call the make:migration Artisan command to create the migration file
        $this->call('make:migration', [
            'name' => "create_{$tableName}_table",
            '--create' => $tableName
        ]);

        // Get the migration path and find the newly created migration file
        $migrationPath = base_path("database/migrations/");
        $migrationFile = collect(File::files($migrationPath))
            ->last(fn($file) => str_contains($file->getFilename(), "create_{$tableName}_table"));

        // If the migration file is found, add the field definitions to the migration
        if ($migrationFile) {
            $content = File::get($migrationFile->getRealPath());
            $content = str_replace('$table->id();', '$table->id();' . "\n" . $migrationFields, $content);
            File::put($migrationFile->getRealPath(), $content);
        }
    }

    /**
     * Generates API and Web routes for the given model and appends them to the respective route files.
     * The routes are based on the model name and its corresponding controller.
     *
     * @param string $modelName The name of the model for which the routes are generated.
     */
    protected function generateRoutes($modelNames)
    {
        if (is_string($modelNames)) {
            $modelNames = [$modelNames];
        }

        $routes = '';

        foreach ($modelNames as $modelName) {
            $resourceName = Str::lower(Str::plural($modelName));
            $routes .= "Route::middleware('auth:sanctum')->apiResource('{$resourceName}', App\Http\Controllers\\{$modelName}Controller::class);";
        }

        $stubContent = file_get_contents(app_path('Console/Commands/stubs/route.stub'));

        $routeContent = str_replace('{{resources}}', $routes, $stubContent);

        $apiFilePath = base_path('routes/api.php');
        file_put_contents($apiFilePath, "\n" . $routeContent, FILE_APPEND);
    }

    /**
     * Generates a form request class for the given model with validation rules based on the specified fields.
     * The generated request class is stored in the app/Http/Requests directory.
     *
     * @param string $modelName The name of the model for which the request is generated.
     * @param array $fields An array of field specifications in the format: 'name:type[:values]'.
     */
    protected function generateRequests($modelName, $fields)
    {
        // Define the path where the request class will be saved
        $path = app_path("Http/Requests/{$modelName}Request.php");

        // Load the request stub template
        $stub = file_get_contents(app_path('Console/Commands/stubs/request.stub'));

        // Replace the model placeholder with the actual model name
        $stub = str_replace('{{model}}', $modelName, $stub);

        // Initialize the string to hold validation rules for the fields
        $fieldsRules = '';

        // Loop through the fields and generate validation rules
        foreach ($fields as $field) {
            if (strpos($field, ':') !== false) {
                [$name, $type] = explode(':', $field, 2);

                // Handle enum fields by adjusting the type format
                if (str_starts_with($type, 'enum:')) {
                    $enumValues = substr($type, 5); // Remove 'enum:' prefix
                    $type = "enum({$enumValues})";
                }

                // Handle enum validation rules
                if (preg_match('/enum\((.*)\)/', $type, $matches)) {
                    $enumValues = str_replace(' ', '', $matches[1]); // Remove spaces
                    $fieldsRules .= "'{$name}' => 'required|in:{$enumValues}',\n            ";
                }
                // Handle other field types like string, text, etc.
                elseif ($type == 'string') {
                    $fieldsRules .= "'{$name}' => 'required|{$type}|max:255',\n            ";
                } elseif ($type == 'text') {
                    $fieldsRules .= "'{$name}' => 'nullable|string',\n            ";
                } else {
                    $fieldsRules .= "'{$name}' => 'required|{$type}',\n            ";
                }
            }
        }

        // Replace the fields rules placeholder with the generated rules
        $stub = str_replace('{{fields_rules}}', rtrim($fieldsRules), $stub);

        // Write the generated request class to the specified path
        File::put($path, $stub);
    }

    /**
     * Generates a controller class for the given model by replacing placeholders in a stub template.
     * The generated controller is stored in the app/Http/Controllers directory.
     *
     * @param string $modelName The name of the model for which the controller is generated.
     */
    protected function generateController($modelName)
    {
        $controllerTemplate = file_get_contents(app_path('Console/Commands/stubs/controller.stub'));
        $controllerTemplate = str_replace('{{modelName}}', $modelName, $controllerTemplate);
        $controllerTemplate = str_replace('{{modelVariable}}', strtolower($modelName), $controllerTemplate);
        File::put(app_path("Http/Controllers/{$modelName}Controller.php"), $controllerTemplate);
        // Generate routes for the model (if needed)
        $this->generateRoutes($modelName);
    }

    /**
     * Generates the views for the given model (index, create, edit, show).
     * The views are saved in the views directory, organized by the model's plural name.
     *
     * @param string $modelName The name of the model for which the views are generated.
     */
    protected function generateViews($modelName)
    {
        // Define the path where the views will be stored
        $viewPath = resource_path("views/" . Str::snake(Str::plural($modelName)));
        File::ensureDirectoryExists($viewPath);
        File::put("{$viewPath}/index.blade.php", $this->getStub('index.stub', $modelName));
        File::put("{$viewPath}/create.blade.php", "<h1>Create {$modelName}</h1>");
        File::put("{$viewPath}/edit.blade.php", "<h1>Edit {$modelName}</h1>");
        File::put("{$viewPath}/show.blade.php", "<h1>Show {$modelName}</h1>");
    }

    /**
     * Parses an array of fields and generates a comma-separated list of field names for the model's fillable property.
     *
     * @param array $fieldArray An array of field specifications in the format: 'name:type'.
     * @return string A comma-separated list of field names for the fillable property.
     */
    protected function parseFieldsForFillable($fieldArray)
    {
        $fields = [];

        // Loop through the field array and extract the field names
        foreach ($fieldArray as $field) {
            if (str_contains($field, ':')) {
                [$name, $type] = explode(':', $field);
                $fields[] = "'{$name}'";
            }
        }

        // Return the comma-separated list of field names
        return implode(', ', $fields);
    }


    /**
     * Parses a string of field definitions and returns an array of field specifications.
     * Each field is represented as a string in the format: 'name:type[:values]'.
     *
     * @param string $fields The string of field definitions.
     * @return array An array of parsed field specifications.
     */
    protected function parseFields($fields)
    {
        if (!$fields) {
            return [];
        }

        $fieldArray = [];
        preg_match_all('/(\w+):(\w+)(\((.*?)\))?/', $fields, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $type = $match[2];
            $values = $match[4] ?? null;

            $fieldString = "{$name}:{$type}";
            if ($values) {
                $fieldString .= ":{$values}";
            }

            $fieldArray[] = $fieldString;
        }

        return $fieldArray;
    }

    /**
     * Parses an array of field definitions and generates the corresponding migration field syntax.
     * Handles enum types separately and generates the appropriate migration code.
     *
     * @param array $fieldArray An array of field specifications in the format: 'name:type[:values]'.
     * @return string A string of migration field definitions.
     */
    protected function parseFieldsForMigration($fieldArray)
    {
        $migrationFields = "";

        foreach ($fieldArray as $field) {
            if (empty($field) || strpos($field, ':') === false) {
                continue;
            }

            [$name, $type] = explode(':', $field, 2);

            // Handle enum fields
            if (str_starts_with($type, "enum:")) {
                $enumValues = str_replace('enum:', '', $type);
                $enumArray = explode(',', $enumValues);
                $enumArray = array_map(fn($v) => "'" . trim($v) . "'", $enumArray);
                $enumString = implode(', ', $enumArray);

                $migrationFields .= "\t\t\t\$table->enum('{$name}', [{$enumString}]);\n";
            } else {
                // Handle other field types like string, text, integer, etc.
                $migrationFields .= "\t\t\t\$table->{$type}('{$name}');\n";
            }
        }

        return $migrationFields;
    }

    /**
     * Retrieves the content of a stub file and replaces placeholders with
     * the model-specific values such as model name, model variable,
     * plural model variable, and route name.
     *
     * @param string $stub The name of the stub file.
     * @param string $modelName The name of the model to replace placeholders.
     * @return string The processed stub content with model-specific values.
     */
    protected function getStub($stub, $modelName)
    {
        $stubPath = app_path("Console/Commands/stubs/{$stub}");
        $stubContent = file_get_contents($stubPath);
        return str_replace(
            ['{{ modelName }}', '{{ modelVariable }}', '{{ modelVariablePlural }}', '{{ routeName }}'],
            [$modelName, strtolower($modelName), Str::plural(strtolower($modelName)), Str::plural(strtolower($modelName))],
            $stubContent
        );
    }
}
